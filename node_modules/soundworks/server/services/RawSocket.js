'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _server = require('../core/server');

var _server2 = _interopRequireDefault(_server);

var _Service2 = require('../core/Service');

var _Service3 = _interopRequireDefault(_Service2);

var _serviceManager = require('../core/serviceManager');

var _serviceManager2 = _interopRequireDefault(_serviceManager);

var _ws = require('ws');

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _pem = require('pem');

var _pem2 = _interopRequireDefault(_pem);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SERVICE_ID = 'service:raw-socket';

/**
 * Protocol defined in configuration is added to these two entry that manage
 * the handshake at the creation of the socket.
 * @private
 */
var baseProtocol = [{ channel: 'service:handshake', type: 'Uint32' }, { channel: 'service:handshake-ack', type: 'Uint8' }];

/**
 * Counter that create tokens in order to match sockets and clients.
 * @private
 */
var counter = 0;

/**
 * Interface for the `raw-socket` service.
 *
 * This service creates an additionnal native socket with its binary type set
 * to `arraybuffer` and focused on performances.
 * It allows the transfert of `TypedArray` data wrapped with a minimal channel
 * mechanism (up to 256 channels).
 *
 * The user-defined protocol must follow the convention:
 * @example
 * const protocol = [
 *   { channel: 'my-channel', type: 'Float32' }
 *   // ...
 * ]
 *
 * Where the `channel` can be any string and the `type` can be interpolated
 * to any `TypedArray` by concatenating `'Array'` at its end.
 *
 * __*The service must be used with its [client-side counterpart]{@link module:soundworks/client.RawSocket}*__
 *
 * @memberof module:soundworks/server
 */

var RawSocket = function (_Service) {
  (0, _inherits3.default)(RawSocket, _Service);

  function RawSocket() {
    (0, _classCallCheck3.default)(this, RawSocket);

    var _this = (0, _possibleConstructorReturn3.default)(this, (RawSocket.__proto__ || (0, _getPrototypeOf2.default)(RawSocket)).call(this, SERVICE_ID));

    var defaults = {
      configItem: 'rawSocket'
    };

    _this.configure(defaults);

    _this._port = null;
    _this._protocol = null;
    _this._channels = null;

    /**
     * Listeners for the incomming messages.
     *
     * @type {Map<client, Set<Function>>}
     * @name _listeners
     * @memberof module:soundworks/server.RawSocket
     * @instance
     * @private
     */
    _this._listeners = new _map2.default();

    _this._tokenClientMap = new _map2.default();
    _this._clientSocketMap = new _map2.default();
    _this._socketClientMap = new _map2.default();

    _this._protocol = baseProtocol;

    // retrieve service config + useHttps
    _this._sharedConfig = _this.require('shared-config');

    _this._onConnection = _this._onConnection.bind(_this);
    return _this;
  }

  (0, _createClass3.default)(RawSocket, [{
    key: 'configure',
    value: function configure(options) {
      if (options.protocol) this._protocol = this._protocol.concat(options.protocol);

      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'configure', this).call(this, options);
    }
  }, {
    key: 'addProtocolDefinition',
    value: function addProtocolDefinition(def) {
      this._protocol.push(def);
    }

    /** @private */

  }, {
    key: 'start',
    value: function start() {
      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'start', this).call(this);

      var configItem = this.options.configItem;
      var config = this._sharedConfig.get(configItem);

      this._port = config.port;

      if (Array.isArray(config.protocol)) this._protocol = this.protocol.concat(config.protocol);

      this._channels = this._protocol.map(function (def) {
        return def.channel;
      });

      // check http / https mode
      var useHttps = _server2.default.config.useHttps;

      // launch http(s) server
      if (!useHttps) {
        var httpServer = _http2.default.createServer();
        this.runServer(httpServer);
      } else {
        var httpsServer = _https2.default.createServer(_server2.default.httpsInfos);
        this.runServer(httpsServer);
      }
    }
  }, {
    key: 'runServer',
    value: function runServer(server) {
      server.listen(this._port, function () {
        // console.log(SERVICE_ID, ': Https server listening on port:', this._port);
      });

      this._wss = new _ws.Server({ server: server });
      this._wss.on('connection', this._onConnection);
      this.ready();
    }

    /** @private */

  }, {
    key: 'connect',
    value: function connect(client) {
      var _this2 = this;

      // send infos to create the socket to the client
      (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'receive', this).call(this, client, 'request', function () {
        var token = counter += 1;
        _this2._tokenClientMap.set(token, client);

        (0, _get3.default)(RawSocket.prototype.__proto__ || (0, _getPrototypeOf2.default)(RawSocket.prototype), 'send', _this2).call(_this2, client, 'infos', _this2._port, _this2._protocol, token);
      });
    }
  }, {
    key: 'disconect',
    value: function disconect(client) {
      var socket = this._clientSocketMap.get(client);

      this._clientSocketMap.delete(client);
      this._socketClientMap.delete(socket);
    }

    /** @private */

  }, {
    key: '_onConnection',
    value: function _onConnection(socket) {
      var _this3 = this;

      socket.on('message', function (buffer) {
        buffer = new Uint8Array(buffer).buffer;
        var index = new Uint8Array(buffer)[0];

        if (!_this3._protocol[index]) throw new Error('Invalid protocol index: ${index}');

        var _protocol$index = _this3._protocol[index],
            channel = _protocol$index.channel,
            type = _protocol$index.type;

        var viewCtor = global[type + 'Array'];
        var data = new viewCtor(buffer, viewCtor.BYTES_PER_ELEMENT);

        if (channel === 'service:handshake') _this3._pairClientSocket(socket, data[0]);else _this3._propagateEvent(socket, channel, data);
      });
    }

    /**
     * Associate the socket with the corresponding client according to the `token`
     *
     * @param {Socket} socket - Socket which receive the message.
     * @param {Number} token - Token to match the client associated to the socket.
     * @private
     */

  }, {
    key: '_pairClientSocket',
    value: function _pairClientSocket(socket, token) {
      var client = this._tokenClientMap.get(token);
      this._clientSocketMap.set(client, socket);
      this._socketClientMap.set(socket, client);
      this._tokenClientMap.delete(token);

      this.send(client, 'service:handshake-ack');
    }

    /**
     * Call all the registered listener associated to a client.
     *
     * @param {Socket} socket - Socket which received the message.
     * @param {String} channel - Channel of the message.
     * @param {TypedArray} data - Received data.
     * @private
     */

  }, {
    key: '_propagateEvent',
    value: function _propagateEvent(socket, channel, data) {
      var client = this._socketClientMap.get(socket);
      var clientListeners = this._listeners.get(client);
      var callbacks = clientListeners[channel];

      callbacks.forEach(function (callback) {
        return callback(data);
      });
    }

    /**
     * Register a callback function on a specific channel.
     *
     * @param {client} client - Client to listen the message from.
     * @param {String} channel - Channel of the message.
     * @param {Function} callback - Callback function.
     */

  }, {
    key: 'receive',
    value: function receive(client, channel, callback) {
      var listeners = this._listeners;

      if (!listeners.has(client)) listeners.set(client, {});

      var clientListeners = listeners.get(client);

      if (!clientListeners[channel]) clientListeners[channel] = new _set2.default();

      clientListeners[channel].add(callback);
    }

    /**
     * Send data to a specific client, on a given channel.
     *
     * @param {client} client - Client to send the message to.
     * @param {String} channel - Channel of the message.
     * @param {TypedArray} data - Data.
     */

  }, {
    key: 'send',
    value: function send(client, channel, data) {
      var socket = this._clientSocketMap.get(client);
      var index = this._channels.indexOf(channel);

      if (index === -1) throw new Error('Undefined channel "' + channel + '"');

      var type = this._protocol[index].type;

      var viewCtor = global[type + 'Array'];
      var size = data ? 1 + data.length : 1;
      var view = new viewCtor(size);

      var channelView = new Uint8Array(viewCtor.BYTES_PER_ELEMENT);
      channelView[0] = index;
      // populate final buffer
      view.set(new viewCtor(channelView.buffer), 0);

      if (data) view.set(data, 1);

      socket.send(view.buffer);
    }

    /**
     * Broadcast data to several client at once.
     *
     * @param {String|Array} clientType - Type or types of client to send the
     *  message to.
     * @param {client} excludeClient - Client to exclude from the broadcast.
     * @param {String} channel - Channel of the message.
     * @param {TypedArray} data - Data.
     */

  }, {
    key: 'broadcast',
    value: function broadcast(clientType, excludeClient, channel, data) {
      if (!Array.isArray(clientType)) clientType = [clientType];

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this._clientSocketMap.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var client = _step.value;

          if (clientType.indexOf(client.type) !== -1 && client !== excludeClient) this.send(client, channel, data);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return RawSocket;
}(_Service3.default);

_serviceManager2.default.register(SERVICE_ID, RawSocket);

exports.default = RawSocket;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJhd1NvY2tldC5qcyJdLCJuYW1lcyI6WyJTRVJWSUNFX0lEIiwiYmFzZVByb3RvY29sIiwiY2hhbm5lbCIsInR5cGUiLCJjb3VudGVyIiwiUmF3U29ja2V0IiwiZGVmYXVsdHMiLCJjb25maWdJdGVtIiwiY29uZmlndXJlIiwiX3BvcnQiLCJfcHJvdG9jb2wiLCJfY2hhbm5lbHMiLCJfbGlzdGVuZXJzIiwiX3Rva2VuQ2xpZW50TWFwIiwiX2NsaWVudFNvY2tldE1hcCIsIl9zb2NrZXRDbGllbnRNYXAiLCJfc2hhcmVkQ29uZmlnIiwicmVxdWlyZSIsIl9vbkNvbm5lY3Rpb24iLCJiaW5kIiwib3B0aW9ucyIsInByb3RvY29sIiwiY29uY2F0IiwiZGVmIiwicHVzaCIsImNvbmZpZyIsImdldCIsInBvcnQiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJ1c2VIdHRwcyIsInNlcnZlciIsImh0dHBTZXJ2ZXIiLCJodHRwIiwiY3JlYXRlU2VydmVyIiwicnVuU2VydmVyIiwiaHR0cHNTZXJ2ZXIiLCJodHRwcyIsImh0dHBzSW5mb3MiLCJsaXN0ZW4iLCJfd3NzIiwiV2ViU29ja2V0U2VydmVyIiwib24iLCJyZWFkeSIsImNsaWVudCIsInRva2VuIiwic2V0Iiwic29ja2V0IiwiZGVsZXRlIiwiYnVmZmVyIiwiVWludDhBcnJheSIsImluZGV4IiwiRXJyb3IiLCJ2aWV3Q3RvciIsImdsb2JhbCIsImRhdGEiLCJCWVRFU19QRVJfRUxFTUVOVCIsIl9wYWlyQ2xpZW50U29ja2V0IiwiX3Byb3BhZ2F0ZUV2ZW50Iiwic2VuZCIsImNsaWVudExpc3RlbmVycyIsImNhbGxiYWNrcyIsImZvckVhY2giLCJjYWxsYmFjayIsImxpc3RlbmVycyIsImhhcyIsImFkZCIsImluZGV4T2YiLCJzaXplIiwibGVuZ3RoIiwidmlldyIsImNoYW5uZWxWaWV3IiwiY2xpZW50VHlwZSIsImV4Y2x1ZGVDbGllbnQiLCJrZXlzIiwiU2VydmljZSIsInNlcnZpY2VNYW5hZ2VyIiwicmVn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VCxFQUFlLENBQWY7O0FBRUZSLGFBQU9ZLElBQVAsQ0FBWVcsS0FBS3JCLE1BQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs4QkFTVXVCLFUsRUFBWUMsYSxFQUFleEUsTyxFQUFTc0QsSSxFQUFNO0FBQ2xELFVBQUksQ0FBQzVCLE1BQU1DLE9BQU4sQ0FBYzRDLFVBQWQsQ0FBTCxFQUNFQSxhQUFhLENBQUNBLFVBQUQsQ0FBYjs7QUFGZ0Q7QUFBQTtBQUFBOztBQUFBO0FBSWxELHdEQUFtQixLQUFLM0QsZ0JBQUwsQ0FBc0I2RCxJQUF0QixFQUFuQiw0R0FBaUQ7QUFBQSxjQUF4QzlCLE1BQXdDOztBQUMvQyxjQUFJNEIsV0FBV0wsT0FBWCxDQUFtQnZCLE9BQU8xQyxJQUExQixNQUFvQyxDQUFDLENBQXJDLElBQTBDMEMsV0FBVzZCLGFBQXpELEVBQ0UsS0FBS2QsSUFBTCxDQUFVZixNQUFWLEVBQWtCM0MsT0FBbEIsRUFBMkJzRCxJQUEzQjtBQUNIO0FBUGlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRbkQ7OztFQS9OcUJvQixpQjs7QUFrT3hCQyx5QkFBZUMsUUFBZixDQUF3QjlFLFVBQXhCLEVBQW9DSyxTQUFwQzs7a0JBRWVBLFMiLCJmaWxlIjoiUmF3U29ja2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNlcnZlciBmcm9tICcuLi9jb3JlL3NlcnZlcic7XG5pbXBvcnQgU2VydmljZSBmcm9tICcuLi9jb3JlL1NlcnZpY2UnO1xuaW1wb3J0IHNlcnZpY2VNYW5hZ2VyIGZyb20gJy4uL2NvcmUvc2VydmljZU1hbmFnZXInO1xuaW1wb3J0IHsgU2VydmVyIGFzIFdlYlNvY2tldFNlcnZlciB9IGZyb20gJ3dzJztcbmltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCBwZW0gZnJvbSAncGVtJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmNvbnN0IFNFUlZJQ0VfSUQgPSAnc2VydmljZTpyYXctc29ja2V0JztcblxuXG4vKipcbiAqIFByb3RvY29sIGRlZmluZWQgaW4gY29uZmlndXJhdGlvbiBpcyBhZGRlZCB0byB0aGVzZSB0d28gZW50cnkgdGhhdCBtYW5hZ2VcbiAqIHRoZSBoYW5kc2hha2UgYXQgdGhlIGNyZWF0aW9uIG9mIHRoZSBzb2NrZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBiYXNlUHJvdG9jb2wgPSBbXG4gIHsgY2hhbm5lbDogJ3NlcnZpY2U6aGFuZHNoYWtlJywgdHlwZTogJ1VpbnQzMicgfSxcbiAgeyBjaGFubmVsOiAnc2VydmljZTpoYW5kc2hha2UtYWNrJywgdHlwZTogJ1VpbnQ4JyB9LFxuXTtcblxuLyoqXG4gKiBDb3VudGVyIHRoYXQgY3JlYXRlIHRva2VucyBpbiBvcmRlciB0byBtYXRjaCBzb2NrZXRzIGFuZCBjbGllbnRzLlxuICogQHByaXZhdGVcbiAqL1xubGV0IGNvdW50ZXIgPSAwO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIGByYXctc29ja2V0YCBzZXJ2aWNlLlxuICpcbiAqIFRoaXMgc2VydmljZSBjcmVhdGVzIGFuIGFkZGl0aW9ubmFsIG5hdGl2ZSBzb2NrZXQgd2l0aCBpdHMgYmluYXJ5IHR5cGUgc2V0XG4gKiB0byBgYXJyYXlidWZmZXJgIGFuZCBmb2N1c2VkIG9uIHBlcmZvcm1hbmNlcy5cbiAqIEl0IGFsbG93cyB0aGUgdHJhbnNmZXJ0IG9mIGBUeXBlZEFycmF5YCBkYXRhIHdyYXBwZWQgd2l0aCBhIG1pbmltYWwgY2hhbm5lbFxuICogbWVjaGFuaXNtICh1cCB0byAyNTYgY2hhbm5lbHMpLlxuICpcbiAqIFRoZSB1c2VyLWRlZmluZWQgcHJvdG9jb2wgbXVzdCBmb2xsb3cgdGhlIGNvbnZlbnRpb246XG4gKiBAZXhhbXBsZVxuICogY29uc3QgcHJvdG9jb2wgPSBbXG4gKiAgIHsgY2hhbm5lbDogJ215LWNoYW5uZWwnLCB0eXBlOiAnRmxvYXQzMicgfVxuICogICAvLyAuLi5cbiAqIF1cbiAqXG4gKiBXaGVyZSB0aGUgYGNoYW5uZWxgIGNhbiBiZSBhbnkgc3RyaW5nIGFuZCB0aGUgYHR5cGVgIGNhbiBiZSBpbnRlcnBvbGF0ZWRcbiAqIHRvIGFueSBgVHlwZWRBcnJheWAgYnkgY29uY2F0ZW5hdGluZyBgJ0FycmF5J2AgYXQgaXRzIGVuZC5cbiAqXG4gKiBfXypUaGUgc2VydmljZSBtdXN0IGJlIHVzZWQgd2l0aCBpdHMgW2NsaWVudC1zaWRlIGNvdW50ZXJwYXJ0XXtAbGluayBtb2R1bGU6c291bmR3b3Jrcy9jbGllbnQuUmF3U29ja2V0fSpfX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6c291bmR3b3Jrcy9zZXJ2ZXJcbiAqL1xuY2xhc3MgUmF3U29ja2V0IGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFNFUlZJQ0VfSUQpO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBjb25maWdJdGVtOiAncmF3U29ja2V0JyxcbiAgICB9O1xuXG4gICAgdGhpcy5jb25maWd1cmUoZGVmYXVsdHMpO1xuXG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBudWxsO1xuICAgIHRoaXMuX2NoYW5uZWxzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIExpc3RlbmVycyBmb3IgdGhlIGluY29tbWluZyBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8Y2xpZW50LCBTZXQ8RnVuY3Rpb24+Pn1cbiAgICAgKiBAbmFtZSBfbGlzdGVuZXJzXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpzb3VuZHdvcmtzL3NlcnZlci5SYXdTb2NrZXRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuICAgIHRoaXMuX3Rva2VuQ2xpZW50TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NsaWVudFNvY2tldE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9zb2NrZXRDbGllbnRNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLl9wcm90b2NvbCA9IGJhc2VQcm90b2NvbDtcblxuICAgIC8vIHJldHJpZXZlIHNlcnZpY2UgY29uZmlnICsgdXNlSHR0cHNcbiAgICB0aGlzLl9zaGFyZWRDb25maWcgPSB0aGlzLnJlcXVpcmUoJ3NoYXJlZC1jb25maWcnKTtcblxuICAgIHRoaXMuX29uQ29ubmVjdGlvbiA9IHRoaXMuX29uQ29ubmVjdGlvbi5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wcm90b2NvbClcbiAgICAgIHRoaXMuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2wuY29uY2F0KG9wdGlvbnMucHJvdG9jb2wpO1xuXG4gICAgc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG5cbiAgYWRkUHJvdG9jb2xEZWZpbml0aW9uKGRlZikge1xuICAgIHRoaXMuX3Byb3RvY29sLnB1c2goZGVmKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgY29uc3QgY29uZmlnSXRlbSA9IHRoaXMub3B0aW9ucy5jb25maWdJdGVtO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX3NoYXJlZENvbmZpZy5nZXQoY29uZmlnSXRlbSk7XG5cbiAgICB0aGlzLl9wb3J0ID0gY29uZmlnLnBvcnQ7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcucHJvdG9jb2wpKVxuICAgICAgdGhpcy5fcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sLmNvbmNhdChjb25maWcucHJvdG9jb2wpO1xuXG4gICAgdGhpcy5fY2hhbm5lbHMgPSB0aGlzLl9wcm90b2NvbC5tYXAoKGRlZikgPT4gZGVmLmNoYW5uZWwpO1xuXG4gICAgLy8gY2hlY2sgaHR0cCAvIGh0dHBzIG1vZGVcbiAgICBsZXQgdXNlSHR0cHMgPSBzZXJ2ZXIuY29uZmlnLnVzZUh0dHBzO1xuXG4gICAgLy8gbGF1bmNoIGh0dHAocykgc2VydmVyXG4gICAgaWYgKCF1c2VIdHRwcykge1xuICAgICAgbGV0IGh0dHBTZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcigpO1xuICAgICAgdGhpcy5ydW5TZXJ2ZXIoaHR0cFNlcnZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGh0dHBzU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHNlcnZlci5odHRwc0luZm9zKTtcbiAgICAgIHRoaXMucnVuU2VydmVyKGh0dHBzU2VydmVyKTtcbiAgICB9XG4gIH1cblxuICBydW5TZXJ2ZXIoc2VydmVyKXtcbiAgICBzZXJ2ZXIubGlzdGVuKHRoaXMuX3BvcnQsICgpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFNFUlZJQ0VfSUQsICc6IEh0dHBzIHNlcnZlciBsaXN0ZW5pbmcgb24gcG9ydDonLCB0aGlzLl9wb3J0KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3dzcyA9IG5ldyBXZWJTb2NrZXRTZXJ2ZXIoeyBzZXJ2ZXI6IHNlcnZlciB9KTtcbiAgICB0aGlzLl93c3Mub24oJ2Nvbm5lY3Rpb24nLCB0aGlzLl9vbkNvbm5lY3Rpb24pO1xuICAgIHRoaXMucmVhZHkoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBjb25uZWN0KGNsaWVudCkge1xuICAgIC8vIHNlbmQgaW5mb3MgdG8gY3JlYXRlIHRoZSBzb2NrZXQgdG8gdGhlIGNsaWVudFxuICAgIHN1cGVyLnJlY2VpdmUoY2xpZW50LCAncmVxdWVzdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuID0gY291bnRlciArPSAxO1xuICAgICAgdGhpcy5fdG9rZW5DbGllbnRNYXAuc2V0KHRva2VuLCBjbGllbnQpO1xuXG4gICAgICBzdXBlci5zZW5kKGNsaWVudCwgJ2luZm9zJywgdGhpcy5fcG9ydCwgdGhpcy5fcHJvdG9jb2wsIHRva2VuKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2NvbmVjdChjbGllbnQpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLl9jbGllbnRTb2NrZXRNYXAuZ2V0KGNsaWVudCk7XG5cbiAgICB0aGlzLl9jbGllbnRTb2NrZXRNYXAuZGVsZXRlKGNsaWVudCk7XG4gICAgdGhpcy5fc29ja2V0Q2xpZW50TWFwLmRlbGV0ZShzb2NrZXQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vbkNvbm5lY3Rpb24oc29ja2V0KSB7XG4gICAgc29ja2V0Lm9uKCdtZXNzYWdlJywgKGJ1ZmZlcikgPT4ge1xuICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKS5idWZmZXI7XG4gICAgICBjb25zdCBpbmRleCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilbMF07XG5cbiAgICAgIGlmICghdGhpcy5fcHJvdG9jb2xbaW5kZXhdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgaW5kZXg6ICR7aW5kZXh9Jyk7XG5cbiAgICAgIGNvbnN0IHsgY2hhbm5lbCwgdHlwZSB9ID0gdGhpcy5fcHJvdG9jb2xbaW5kZXhdO1xuICAgICAgY29uc3Qgdmlld0N0b3IgPSBnbG9iYWxbYCR7dHlwZX1BcnJheWBdO1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyB2aWV3Q3RvcihidWZmZXIsIHZpZXdDdG9yLkJZVEVTX1BFUl9FTEVNRU5UKTtcblxuICAgICAgaWYgKGNoYW5uZWwgPT09ICdzZXJ2aWNlOmhhbmRzaGFrZScpXG4gICAgICAgIHRoaXMuX3BhaXJDbGllbnRTb2NrZXQoc29ja2V0LCBkYXRhWzBdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlRXZlbnQoc29ja2V0LCBjaGFubmVsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGUgdGhlIHNvY2tldCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGNsaWVudCBhY2NvcmRpbmcgdG8gdGhlIGB0b2tlbmBcbiAgICpcbiAgICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldCAtIFNvY2tldCB3aGljaCByZWNlaXZlIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdG9rZW4gLSBUb2tlbiB0byBtYXRjaCB0aGUgY2xpZW50IGFzc29jaWF0ZWQgdG8gdGhlIHNvY2tldC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYWlyQ2xpZW50U29ja2V0KHNvY2tldCwgdG9rZW4pIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLl90b2tlbkNsaWVudE1hcC5nZXQodG9rZW4pO1xuICAgIHRoaXMuX2NsaWVudFNvY2tldE1hcC5zZXQoY2xpZW50LCBzb2NrZXQpO1xuICAgIHRoaXMuX3NvY2tldENsaWVudE1hcC5zZXQoc29ja2V0LCBjbGllbnQpO1xuICAgIHRoaXMuX3Rva2VuQ2xpZW50TWFwLmRlbGV0ZSh0b2tlbik7XG5cbiAgICB0aGlzLnNlbmQoY2xpZW50LCAnc2VydmljZTpoYW5kc2hha2UtYWNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhbGwgdGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXIgYXNzb2NpYXRlZCB0byBhIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldCAtIFNvY2tldCB3aGljaCByZWNlaXZlZCB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBDaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGRhdGEgLSBSZWNlaXZlZCBkYXRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb3BhZ2F0ZUV2ZW50KHNvY2tldCwgY2hhbm5lbCwgZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuX3NvY2tldENsaWVudE1hcC5nZXQoc29ja2V0KTtcbiAgICBjb25zdCBjbGllbnRMaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGNsaWVudCk7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY2xpZW50TGlzdGVuZXJzW2NoYW5uZWxdO1xuXG4gICAgY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbiBvbiBhIHNwZWNpZmljIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Y2xpZW50fSBjbGllbnQgLSBDbGllbnQgdG8gbGlzdGVuIHRoZSBtZXNzYWdlIGZyb20uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFubmVsIC0gQ2hhbm5lbCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIHJlY2VpdmUoY2xpZW50LCBjaGFubmVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgIGlmICghbGlzdGVuZXJzLmhhcyhjbGllbnQpKVxuICAgICAgbGlzdGVuZXJzLnNldChjbGllbnQsIHt9KTtcblxuICAgIGNvbnN0IGNsaWVudExpc3RlbmVycyA9IGxpc3RlbmVycy5nZXQoY2xpZW50KTtcblxuICAgIGlmICghY2xpZW50TGlzdGVuZXJzW2NoYW5uZWxdKVxuICAgICAgY2xpZW50TGlzdGVuZXJzW2NoYW5uZWxdID0gbmV3IFNldCgpO1xuXG4gICAgY2xpZW50TGlzdGVuZXJzW2NoYW5uZWxdLmFkZChjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBkYXRhIHRvIGEgc3BlY2lmaWMgY2xpZW50LCBvbiBhIGdpdmVuIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Y2xpZW50fSBjbGllbnQgLSBDbGllbnQgdG8gc2VuZCB0aGUgbWVzc2FnZSB0by5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBDaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGRhdGEgLSBEYXRhLlxuICAgKi9cbiAgc2VuZChjbGllbnQsIGNoYW5uZWwsIGRhdGEpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLl9jbGllbnRTb2NrZXRNYXAuZ2V0KGNsaWVudCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jaGFubmVscy5pbmRleE9mKGNoYW5uZWwpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGNoYW5uZWwgXCIke2NoYW5uZWx9XCJgKTtcblxuICAgIGNvbnN0IHsgdHlwZSB9ID0gdGhpcy5fcHJvdG9jb2xbaW5kZXhdO1xuICAgIGNvbnN0IHZpZXdDdG9yID0gZ2xvYmFsW2Ake3R5cGV9QXJyYXlgXTtcbiAgICBjb25zdCBzaXplID0gZGF0YSA/IDEgKyBkYXRhLmxlbmd0aCA6IDE7XG4gICAgY29uc3QgdmlldyA9IG5ldyB2aWV3Q3RvcihzaXplKTtcblxuICAgIGNvbnN0IGNoYW5uZWxWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmlld0N0b3IuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIGNoYW5uZWxWaWV3WzBdID0gaW5kZXg7XG4gICAgLy8gcG9wdWxhdGUgZmluYWwgYnVmZmVyXG4gICAgdmlldy5zZXQobmV3IHZpZXdDdG9yKGNoYW5uZWxWaWV3LmJ1ZmZlciksIDApO1xuXG4gICAgaWYgKGRhdGEpXG4gICAgICB2aWV3LnNldChkYXRhLCAxKTtcblxuICAgIHNvY2tldC5zZW5kKHZpZXcuYnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3QgZGF0YSB0byBzZXZlcmFsIGNsaWVudCBhdCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gY2xpZW50VHlwZSAtIFR5cGUgb3IgdHlwZXMgb2YgY2xpZW50IHRvIHNlbmQgdGhlXG4gICAqICBtZXNzYWdlIHRvLlxuICAgKiBAcGFyYW0ge2NsaWVudH0gZXhjbHVkZUNsaWVudCAtIENsaWVudCB0byBleGNsdWRlIGZyb20gdGhlIGJyb2FkY2FzdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYW5uZWwgLSBDaGFubmVsIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGRhdGEgLSBEYXRhLlxuICAgKi9cbiAgYnJvYWRjYXN0KGNsaWVudFR5cGUsIGV4Y2x1ZGVDbGllbnQsIGNoYW5uZWwsIGRhdGEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2xpZW50VHlwZSkpXG4gICAgICBjbGllbnRUeXBlID0gW2NsaWVudFR5cGVdO1xuXG4gICAgZm9yIChsZXQgY2xpZW50IG9mIHRoaXMuX2NsaWVudFNvY2tldE1hcC5rZXlzKCkpIHtcbiAgICAgIGlmIChjbGllbnRUeXBlLmluZGV4T2YoY2xpZW50LnR5cGUpICE9PSAtMSAmJiBjbGllbnQgIT09IGV4Y2x1ZGVDbGllbnQpXG4gICAgICAgIHRoaXMuc2VuZChjbGllbnQsIGNoYW5uZWwsIGRhdGEpO1xuICAgIH1cbiAgfVxufVxuXG5zZXJ2aWNlTWFuYWdlci5yZWdpc3RlcihTRVJWSUNFX0lELCBSYXdTb2NrZXQpO1xuXG5leHBvcnQgZGVmYXVsdCBSYXdTb2NrZXQ7XG4iXX0=