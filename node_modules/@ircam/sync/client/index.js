'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('sync');

////// helpers

/**
 * Order min and max attributes.
 *
 * @private
 * @param {Object} that with min and max attributes
 * @returns {Object} with min and man attributes, swapped if that.min > that.max
 */
/**
 * @fileOverview Estimation of a server time from a client time.
 *
 * @see {@link https://hal.archives-ouvertes.fr/hal-01304889v1}
 * Stabilisation added after the article.
 */

function orderMinMax(that) {
  if (typeof that !== 'undefined' && typeof that.min !== 'undefined' && typeof that.max !== 'undefined' && that.min > that.max) {
    var tmp = that.min;
    that.min = that.max;
    that.max = tmp;
  }
  return that;
}

/**
 * Mean over an array, selecting one dimension of the array values.
 *
 * @private
 * @param {Array.<Array.<Number>>} array
 * @param {Number} [dimension=0]
 * @returns {Number} mean
 */
function mean(array) {
  var dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return array.reduce(function (p, q) {
    return p + q[dimension];
  }, 0) / array.length;
}

/**
 * Function used to sort long-term data, using first and second dimensions, in
 * that order.
 *
 * @param {Array.<Number>} a
 * @param {Number.<Number>} b
 * @returns {Number} negative if a < b, positive if a > b, or 0
 */
function dataCompare(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

var SyncClient = function () {
  /**
   * @callback SyncClient~getTimeFunction
   * @return {Number} monotonic, ever increasing, time in second. When possible
   *   the server code should define its own origin (i.e. `time=0`) in order to
   *   maximize the resolution of the clock for a long period of time. When
   *   `SyncServer~start` is called the clock should be running
   *   (cf. `audioContext.currentTime` that needs user interaction to start)
   **/

  /**
   * @callback SyncClient~sendFunction
   * @see {@linkcode SyncServer~receiveFunction}
   * @param {Number} pingId unique identifier
   * @param {Number} clientPingTime time-stamp of ping emission
   **/

  /**
   * @callback SyncClient~receiveFunction
   * @see {@linkcode SyncServer~sendFunction}
   * @param {SyncClient~receiveCallback} receiveCallback called on each message
   *   matching messageType.
   **/

  /**
   * @callback SyncClient~receiveCallback
   * @param {Number} pingId unique identifier
   * @param {Number} clientPingTime time-stamp of ping emission
   * @param {Number} serverPingTime time-stamp of ping reception
   * @param {Number} serverPongTime time-stamp of pong emission
   **/

  /**
   * @callback SyncClient~reportFunction
   * @param {Object} report
   * @param {String} report.status `new`, `startup`, `training` (offset
   *   adaptation), or `sync` (offset and speed adaptation).
   * @param {Number} report.statusDuration duration since last status
   *   change.
   * @param {Number} report.timeOffset time difference between local time and
   *   sync time, in seconds.
   * @param {Number} report.frequencyRatio time ratio between local
   *   time and sync time.
   * @param {String} report.connection `offline` or `online`
   * @param {Number} report.connectionDuration duration since last connection
   *   change.
   * @param {Number} report.connectionTimeOut duration, in seconds, before
   *   a time-out occurs.
   * @param {Number} report.travelDuration duration of a ping-pong round-trip,
   *   in seconds, mean over the the last ping-pong series.
   * @param {Number} report.travelDurationMin duration of a ping-pong
   *   round-trip, in seconds, minimum over the the last ping-pong series.
   * @param {Number} report.travelDurationMax duration of a ping-pong
   *   round-trip, in seconds, maximum over the the last ping-pong series.
   **/

  /**
   * This is the constructor. See {@linkcode SyncClient~start} method to
   * actually start a synchronisation process.
   *
   * @constructs SyncClient
   * @param {SyncClient~getTimeFunction} getTimeFunction
   * @param {Object} [options]
   * @param {Object} [options.pingTimeOutDelay] range of duration (in seconds) to
   * consider a ping was not ponged back
   * @param {Number} [options.pingTimeOutDelay.min=1] min and max must be set together
   * @param {Number} [options.pingTimeOutDelay.max=30] min and max must be set together
   * @param {Number} [options.pingSeriesIterations=10] number of ping-pongs in a
   * series
   * @param {Number} [options.pingSeriesPeriod=0.250] interval (in seconds) between pings
   * in a series
   * @param {Number} [options.pingSeriesDelay] range of interval (in
   * seconds) between ping-pong series
   * @param {Number} [options.pingSeriesDelay.min=10] min and max must be set together
   * @param {Number} [options.pingSeriesDelay.max=20] min and max must be set together
   * @param {Number} [options.longTermDataTrainingDuration=120] duration of
   * training, in seconds, approximately, before using the estimate of
   * clock frequency
   * @param {Number} [options.longTermDataDuration=900] estimate synchronisation over
   *  this duration, in seconds, approximately
   */
  function SyncClient(getTimeFunction) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, SyncClient);

    this.pingTimeoutDelay = options.pingTimeoutDelay || { min: 1, max: 30 };
    orderMinMax(this.pingTimeoutDelay);

    this.pingSeriesIterations = options.pingSeriesIterations || 10;
    this.pingSeriesPeriod = typeof options.pingSeriesPeriod !== 'undefined' ? options.pingSeriesPeriod : 0.250;
    this.pingSeriesDelay = options.pingSeriesDelay || { min: 10, max: 20 };
    orderMinMax(this.pingSeriesDelay);

    this.pingDelay = 0; // current delay before next ping
    this.timeoutId = 0; // to cancel timeout on pong
    this.pingId = 0; // absolute ID to mach pong against

    this.pingSeriesCount = 0; // elapsed pings in a series
    this.seriesData = []; // circular buffer
    this.seriesDataNextIndex = 0; // next index to write in circular buffer
    this.seriesDataLength = this.pingSeriesIterations; // size of circular buffer

    this.longTermDataTrainingDuration = options.longTermDataTrainingDuration || 120;

    // use a fixed-size circular buffer, even if it does not match
    // exactly the required duration
    this.longTermDataDuration = options.longTermDataDuration || 900;
    this.longTermDataLength = Math.max(2, this.longTermDataDuration / (0.5 * (this.pingSeriesDelay.min + this.pingSeriesDelay.max)));

    this.longTermData = []; // circular buffer
    this.longTermDataNextIndex = 0; // next index to write in circular buffer

    this.timeOffset = 0; // mean of (serverTime - clientTime) in the last series
    this.travelDuration = 0;
    this.travelDurationMin = 0;
    this.travelDurationMax = 0;

    // T(t) = T0 + R * (t - t0)
    this.serverTimeReference = 0; // T0
    this.clientTimeReference = 0; // t0
    this.frequencyRatio = 1; // R

    this.pingTimeoutDelay.current = this.pingTimeoutDelay.min;

    this.getTimeFunction = getTimeFunction;

    this.status = 'new';
    this.statusChangedTime = 0;

    this.connectionStatus = 'offline';
    this.connectionStatusChangedTime = 0;
  }

  /**
   * Set status, and set this.statusChangedTime, to later
   * use see {@linkcode SyncClient~getStatusDuration}
   * and {@linkcode SyncClient~reportStatus}.
   *
   * @function SyncClient~setStatus
   * @param {String} status
   * @returns {Object} this
   */


  (0, _createClass3.default)(SyncClient, [{
    key: 'setStatus',
    value: function setStatus(status) {
      if (status !== this.status) {
        this.status = status;
        this.statusChangedTime = this.getLocalTime();
      }
      return this;
    }

    /**
     * Get time since last status change. See {@linkcode SyncClient~setStatus}
     *
     * @function SyncClient~getStatusDuration
     * @returns {Number} time, in seconds, since last status change.
     */

  }, {
    key: 'getStatusDuration',
    value: function getStatusDuration() {
      return Math.max(0, this.getLocalTime() - this.statusChangedTime);
    }

    /**
     * Set connectionStatus, and set this.connectionStatusChangedTime,
     * to later use see {@linkcode SyncClient~getConnectionStatusDuration}
     * and {@linkcode SyncClient~reportStatus}.
     *
     * @function SyncClient~setConnectionStatus
     * @param {String} connectionStatus
     * @returns {Object} this
     */

  }, {
    key: 'setConnectionStatus',
    value: function setConnectionStatus(connectionStatus) {
      if (connectionStatus !== this.connectionStatus) {
        this.connectionStatus = connectionStatus;
        this.connectionStatusChangedTime = this.getLocalTime();
      }
      return this;
    }

    /**
     * Get time since last connectionStatus change.
     * See {@linkcode SyncClient~setConnectionStatus}
     *
     * @function SyncClient~getConnectionStatusDuration
     * @returns {Number} time, in seconds, since last connectionStatus change.
     */

  }, {
    key: 'getConnectionStatusDuration',
    value: function getConnectionStatusDuration() {
      return Math.max(0, this.getLocalTime() - this.connectionStatusChangedTime);
    }

    /**
     * Report the status of the synchronisation process, if
     * reportFunction is defined.
     *
     * @function SyncClient~reportStatus
     * @param {SyncClient~reportFunction} reportFunction
     */

  }, {
    key: 'reportStatus',
    value: function reportStatus(reportFunction) {
      if (typeof reportFunction !== 'undefined') {
        reportFunction({
          status: this.status,
          statusDuration: this.getStatusDuration(),
          timeOffset: this.timeOffset,
          frequencyRatio: this.frequencyRatio,
          connection: this.connectionStatus,
          connectionDuration: this.getConnectionStatusDuration(),
          connectionTimeOut: this.pingTimeoutDelay.current,
          travelDuration: this.travelDuration,
          travelDurationMin: this.travelDurationMin,
          travelDurationMax: this.travelDurationMax
        });
      }
    }

    /**
     * Process to send ping messages.
     *
     * @private
     * @function SyncClient~__syncLoop
     * @param {SyncClient~sendFunction} sendFunction
     * @param {SyncClient~reportFunction} reportFunction
     */

  }, {
    key: '__syncLoop',
    value: function __syncLoop(sendFunction, reportFunction) {
      var _this = this;

      clearTimeout(this.timeoutId);
      ++this.pingId;
      sendFunction(this.pingId, this.getLocalTime());

      this.timeoutId = setTimeout(function () {
        // increase timeout duration on timeout, to avoid overflow
        _this.pingTimeoutDelay.current = Math.min(_this.pingTimeoutDelay.current * 2, _this.pingTimeoutDelay.max);
        log('sync:ping timeout > %s', _this.pingTimeoutDelay.current);
        _this.setConnectionStatus('offline');
        _this.reportStatus(reportFunction);
        // retry (yes, always increment pingId)
        _this.__syncLoop(sendFunction, reportFunction);
      }, Math.ceil(1000 * this.pingTimeoutDelay.current));
    }

    /**
     * Start a synchronisation process by registering the receive
     * function passed as second parameter. Then, send regular messages
     * to the server, using the send function passed as first parameter.
     *
     * @function SyncClient~start
     * @param {SyncClient~sendFunction} sendFunction
     * @param {SyncClient~receiveFunction} receiveFunction to register
     * @param {SyncClient~reportFunction} reportFunction if defined, is called to
     *   report the status, on each status change
     */

  }, {
    key: 'start',
    value: function start(sendFunction, receiveFunction, reportFunction) {
      var _this2 = this;

      this.setStatus('startup');
      this.setConnectionStatus('offline');

      this.seriesData = [];
      this.seriesDataNextIndex = 0;

      this.longTermData = [];
      this.longTermDataNextIndex = 0;

      receiveFunction(function (pingId, clientPingTime, serverPingTime, serverPongTime) {
        // accept only the pong that corresponds to the last ping
        if (pingId === _this2.pingId) {
          ++_this2.pingSeriesCount;
          clearTimeout(_this2.timeoutId);
          _this2.setConnectionStatus('online');
          // reduce timeout duration on pong, for better reactivity
          _this2.pingTimeoutDelay.current = Math.max(_this2.pingTimeoutDelay.current * 0.75, _this2.pingTimeoutDelay.min);

          // time-differences are valid on a single-side only (client or server)
          var clientPongTime = _this2.getLocalTime();
          var clientTime = 0.5 * (clientPongTime + clientPingTime);
          var serverTime = 0.5 * (serverPongTime + serverPingTime);
          var travelDuration = Math.max(0, clientPongTime - clientPingTime - (serverPongTime - serverPingTime));
          var offsetTime = serverTime - clientTime;

          // order is important for sorting, later.
          _this2.seriesData[_this2.seriesDataNextIndex] = [travelDuration, offsetTime, clientTime, serverTime];
          _this2.seriesDataNextIndex = ++_this2.seriesDataNextIndex % _this2.seriesDataLength;

          // log('ping %s, travel = %s, offset = %s, client = %s, server = %s',
          //       pingId, travelDuration, offsetTime, clientTime, serverTime);

          // end of a series
          if (_this2.pingSeriesCount >= _this2.pingSeriesIterations && _this2.seriesData.length >= _this2.seriesDataLength) {
            // plan the begining of the next series
            _this2.pingDelay = _this2.pingSeriesDelay.min + Math.random() * (_this2.pingSeriesDelay.max - _this2.pingSeriesDelay.min);
            _this2.pingSeriesCount = 0;

            // sort by travel time first, then offset time.
            var sorted = _this2.seriesData.slice(0).sort(dataCompare);

            var seriesTravelDuration = sorted[0][0];

            // When the clock tick is long enough,
            // some travel times (dimension 0) might be identical.
            // Then, use the offset median (dimension 1 is the second sort key)
            // of shortest travel duration
            var quick = 0;
            while (quick < sorted.length && sorted[quick][0] <= seriesTravelDuration * 1.01) {
              ++quick;
            }
            quick = Math.max(0, quick - 1);
            var median = Math.floor(quick / 2);

            var seriesClientTime = sorted[median][2];
            var seriesServerTime = sorted[median][3];
            var seriesClientSquaredTime = seriesClientTime * seriesClientTime;
            var seriesClientServerTime = seriesClientTime * seriesServerTime;

            _this2.longTermData[_this2.longTermDataNextIndex] = [seriesTravelDuration, seriesClientTime, seriesServerTime, seriesClientSquaredTime, seriesClientServerTime];
            _this2.longTermDataNextIndex = ++_this2.longTermDataNextIndex % _this2.longTermDataLength;

            // mean of the time offset over 3 samples around median
            // (limited to shortest travel duration)
            var aroundMedian = sorted.slice(Math.max(0, median - 1), Math.min(quick, median + 1) + 1);
            _this2.timeOffset = mean(aroundMedian, 1);

            if (_this2.status === 'startup' || _this2.status === 'training' && _this2.getStatusDuration() < _this2.longTermDataTrainingDuration) {
              // set only the phase offset, not the frequency
              _this2.serverTimeReference = _this2.timeOffset;
              _this2.clientTimeReference = 0;
              _this2.frequencyRatio = 1;
              _this2.setStatus('training');
              log('T = %s + %s * (%s - %s) = %s', _this2.serverTimeReference, _this2.frequencyRatio, seriesClientTime, _this2.clientTimeReference, _this2.getSyncTime(seriesClientTime));
            }

            if (_this2.status === 'training' && _this2.getStatusDuration() >= _this2.longTermDataTrainingDuration || _this2.status === 'sync') {
              // linear regression, R = covariance(t,T) / variance(t)
              var regClientTime = mean(_this2.longTermData, 1);
              var regServerTime = mean(_this2.longTermData, 2);
              var regClientSquaredTime = mean(_this2.longTermData, 3);
              var regClientServerTime = mean(_this2.longTermData, 4);

              var covariance = regClientServerTime - regClientTime * regServerTime;
              var variance = regClientSquaredTime - regClientTime * regClientTime;
              if (variance > 0) {
                // update freq and shift
                _this2.frequencyRatio = covariance / variance;
                _this2.clientTimeReference = regClientTime;
                _this2.serverTimeReference = regServerTime;

                // 0.05% is a lot (500 PPM, like an old mechanical clock)
                if (_this2.frequencyRatio > 0.9995 && _this2.frequencyRatio < 1.0005) {
                  _this2.setStatus('sync');
                } else {
                  log('clock frequency ratio out of sync: %s, training again', _this2.frequencyRatio);
                  // start the training again from the last series
                  _this2.serverTimeReference = _this2.timeOffset; // offset only
                  _this2.clientTimeReference = 0;
                  _this2.frequencyRatio = 1;
                  _this2.setStatus('training');

                  _this2.longTermData[0] = [seriesTravelDuration, seriesClientTime, seriesServerTime, seriesClientSquaredTime, seriesClientServerTime];
                  _this2.longTermData.length = 1;
                  _this2.longTermDataNextIndex = 1;
                }
              }

              log('T = %s + %s * (%s - %s) = %s', _this2.serverTimeReference, _this2.frequencyRatio, seriesClientTime, _this2.clientTimeReference, _this2.getSyncTime(seriesClientTime));
            }

            _this2.travelDuration = mean(sorted, 0);
            _this2.travelDurationMin = sorted[0][0];
            _this2.travelDurationMax = sorted[sorted.length - 1][0];

            _this2.reportStatus(reportFunction);
          } else {
            // we are in a series, use the pingInterval value
            _this2.pingDelay = _this2.pingSeriesPeriod;
          }

          _this2.timeoutId = setTimeout(function () {
            _this2.__syncLoop(sendFunction, reportFunction);
          }, Math.ceil(1000 * _this2.pingDelay));
        } // ping and pong ID match
      }); // receive function

      this.__syncLoop(sendFunction, reportFunction);
    }

    /**
     * Get local time, or convert a synchronised time to a local time.
     *
     * @function SyncClient~getLocalTime
     * @param {Number} syncTime undefined to get local time
     * @returns {Number} local time, in seconds
     */

  }, {
    key: 'getLocalTime',
    value: function getLocalTime(syncTime) {
      if (typeof syncTime !== 'undefined') {
        // conversion: t(T) = t0 + (T - T0) / R
        return this.clientTimeReference + (syncTime - this.serverTimeReference) / this.frequencyRatio;
      } else {
        // read local clock
        return this.getTimeFunction();
      }
    }

    /**
     * Get synchronised time, or convert a local time to a synchronised time.
     *
     * @function SyncClient~getSyncTime
     * @param {Number} localTime undefined to get synchronised time
     * @returns {Number} synchronised time, in seconds.
     */

  }, {
    key: 'getSyncTime',
    value: function getSyncTime() {
      var localTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLocalTime();

      // always convert: T(t) = T0 + R * (t - t0)
      return this.serverTimeReference + this.frequencyRatio * (localTime - this.clientTimeReference);
    }
  }]);
  return SyncClient;
}();

exports.default = SyncClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbImxvZyIsIm9yZGVyTWluTWF4IiwidGhhdCIsIm1pbiIsIm1heCIsInRtcCIsIm1lYW4iLCJhcnJheSIsImRpbWVuc2lvbiIsInJlZHVjZSIsInAiLCJxIiwibGVuZ3RoIiwiZGF0YUNvbXBhcmUiLCJhIiwiYiIsIlN5bmNDbGllbnQiLCJnZXRUaW1lRnVuY3Rpb24iLCJvcHRpb25zIiwicGluZ1RpbWVvdXREZWxheSIsInBpbmdTZXJpZXNJdGVyYXRpb25zIiwicGluZ1Nlcmllc1BlcmlvZCIsInBpbmdTZXJpZXNEZWxheSIsInBpbmdEZWxheSIsInRpbWVvdXRJZCIsInBpbmdJZCIsInBpbmdTZXJpZXNDb3VudCIsInNlcmllc0RhdGEiLCJzZXJpZXNEYXRhTmV4dEluZGV4Iiwic2VyaWVzRGF0YUxlbmd0aCIsImxvbmdUZXJtRGF0YVRyYWluaW5nRHVyYXRpb24iLCJsb25nVGVybURhdGFEdXJhdGlvbiIsImxvbmdUZXJtRGF0YUxlbmd0aCIsIk1hdGgiLCJsb25nVGVybURhdGEiLCJsb25nVGVybURhdGFOZXh0SW5kZXgiLCJ0aW1lT2Zmc2V0IiwidHJhdmVsRHVyYXRpb24iLCJ0cmF2ZWxEdXJhdGlvbk1pbiIsInRyYXZlbER1cmF0aW9uTWF4Iiwic2VydmVyVGltZVJlZmVyZW5jZSIsImNsaWVudFRpbWVSZWZlcmVuY2UiLCJmcmVxdWVuY3lSYXRpbyIsImN1cnJlbnQiLCJzdGF0dXMiLCJzdGF0dXNDaGFuZ2VkVGltZSIsImNvbm5lY3Rpb25TdGF0dXMiLCJjb25uZWN0aW9uU3RhdHVzQ2hhbmdlZFRpbWUiLCJnZXRMb2NhbFRpbWUiLCJyZXBvcnRGdW5jdGlvbiIsInN0YXR1c0R1cmF0aW9uIiwiZ2V0U3RhdHVzRHVyYXRpb24iLCJjb25uZWN0aW9uIiwiY29ubmVjdGlvbkR1cmF0aW9uIiwiZ2V0Q29ubmVjdGlvblN0YXR1c0R1cmF0aW9uIiwiY29ubmVjdGlvblRpbWVPdXQiLCJzZW5kRnVuY3Rpb24iLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2V0Q29ubmVjdGlvblN0YXR1cyIsInJlcG9ydFN0YXR1cyIsIl9fc3luY0xvb3AiLCJjZWlsIiwicmVjZWl2ZUZ1bmN0aW9uIiwic2V0U3RhdHVzIiwiY2xpZW50UGluZ1RpbWUiLCJzZXJ2ZXJQaW5nVGltZSIsInNlcnZlclBvbmdUaW1lIiwiY2xpZW50UG9uZ1RpbWUiLCJjbGllbnRUaW1lIiwic2VydmVyVGltZSIsIm9mZnNldFRpbWUiLCJyYW5kb20iLCJzb3J0ZWQiLCJzbGljZSIsInNvcnQiLCJzZXJpZXNUcmF2ZWxEdXJhdGlvbiIsInF1aWNrIiwibWVkaWFuIiwiZmxvb3IiLCJzZXJpZXNDbGllbnRUaW1lIiwic2VyaWVzU2VydmVyVGltZSIsInNlcmllc0NsaWVudFNxdWFyZWRUaW1lIiwic2VyaWVzQ2xpZW50U2VydmVyVGltZSIsImFyb3VuZE1lZGlhbiIsImdldFN5bmNUaW1lIiwicmVnQ2xpZW50VGltZSIsInJlZ1NlcnZlclRpbWUiLCJyZWdDbGllbnRTcXVhcmVkVGltZSIsInJlZ0NsaWVudFNlcnZlclRpbWUiLCJjb3ZhcmlhbmNlIiwidmFyaWFuY2UiLCJzeW5jVGltZSIsImxvY2FsVGltZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFPQTs7Ozs7O0FBQ0EsSUFBTUEsTUFBTSxxQkFBTSxNQUFOLENBQVo7O0FBRUE7O0FBRUE7Ozs7Ozs7QUFaQTs7Ozs7OztBQW1CQSxTQUFTQyxXQUFULENBQXFCQyxJQUFyQixFQUEyQjtBQUN6QixNQUFHLE9BQU9BLElBQVAsS0FBZ0IsV0FBaEIsSUFDRyxPQUFPQSxLQUFLQyxHQUFaLEtBQW9CLFdBRHZCLElBQ3NDLE9BQU9ELEtBQUtFLEdBQVosS0FBb0IsV0FEMUQsSUFFR0YsS0FBS0MsR0FBTCxHQUFXRCxLQUFLRSxHQUZ0QixFQUUyQjtBQUN6QixRQUFNQyxNQUFNSCxLQUFLQyxHQUFqQjtBQUNBRCxTQUFLQyxHQUFMLEdBQVdELEtBQUtFLEdBQWhCO0FBQ0FGLFNBQUtFLEdB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RCxtQkFBeEMsQ0FESjtBQUVEOzs7OztrQkFHWXpCLFUiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgRXN0aW1hdGlvbiBvZiBhIHNlcnZlciB0aW1lIGZyb20gYSBjbGllbnQgdGltZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2hhbC5hcmNoaXZlcy1vdXZlcnRlcy5mci9oYWwtMDEzMDQ4ODl2MX1cbiAqIFN0YWJpbGlzYXRpb24gYWRkZWQgYWZ0ZXIgdGhlIGFydGljbGUuXG4gKi9cblxuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmNvbnN0IGxvZyA9IGRlYnVnKCdzeW5jJyk7XG5cbi8vLy8vLyBoZWxwZXJzXG5cbi8qKlxuICogT3JkZXIgbWluIGFuZCBtYXggYXR0cmlidXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRoYXQgd2l0aCBtaW4gYW5kIG1heCBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB3aXRoIG1pbiBhbmQgbWFuIGF0dHJpYnV0ZXMsIHN3YXBwZWQgaWYgdGhhdC5taW4gPiB0aGF0Lm1heFxuICovXG5mdW5jdGlvbiBvcmRlck1pbk1heCh0aGF0KSB7XG4gIGlmKHR5cGVvZiB0aGF0ICE9PSAndW5kZWZpbmVkJ1xuICAgICAmJiB0eXBlb2YgdGhhdC5taW4gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGF0Lm1heCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgJiYgdGhhdC5taW4gPiB0aGF0Lm1heCkge1xuICAgIGNvbnN0IHRtcCA9IHRoYXQubWluO1xuICAgIHRoYXQubWluID0gdGhhdC5tYXg7XG4gICAgdGhhdC5tYXggPSB0bXA7XG4gIH1cbiAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogTWVhbiBvdmVyIGFuIGFycmF5LCBzZWxlY3Rpbmcgb25lIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48TnVtYmVyPj59IGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gW2RpbWVuc2lvbj0wXVxuICogQHJldHVybnMge051bWJlcn0gbWVhblxuICovXG5mdW5jdGlvbiBtZWFuKGFycmF5LCBkaW1lbnNpb24gPSAwKSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHAsIHEpID0+IHAgKyBxW2RpbWVuc2lvbl0sIDApIC8gYXJyYXkubGVuZ3RoO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gc29ydCBsb25nLXRlcm0gZGF0YSwgdXNpbmcgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb25zLCBpblxuICogdGhhdCBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBhXG4gKiBAcGFyYW0ge051bWJlci48TnVtYmVyPn0gYlxuICogQHJldHVybnMge051bWJlcn0gbmVnYXRpdmUgaWYgYSA8IGIsIHBvc2l0aXZlIGlmIGEgPiBiLCBvciAwXG4gKi9cbmZ1bmN0aW9uIGRhdGFDb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xufVxuXG5jbGFzcyBTeW5jQ2xpZW50IHtcbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fmdldFRpbWVGdW5jdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1vbm90b25pYywgZXZlciBpbmNyZWFzaW5nLCB0aW1lIGluIHNlY29uZC4gV2hlbiBwb3NzaWJsZVxuICAgKiAgIHRoZSBzZXJ2ZXIgY29kZSBzaG91bGQgZGVmaW5lIGl0cyBvd24gb3JpZ2luIChpLmUuIGB0aW1lPTBgKSBpbiBvcmRlciB0b1xuICAgKiAgIG1heGltaXplIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjbG9jayBmb3IgYSBsb25nIHBlcmlvZCBvZiB0aW1lLiBXaGVuXG4gICAqICAgYFN5bmNTZXJ2ZXJ+c3RhcnRgIGlzIGNhbGxlZCB0aGUgY2xvY2sgc2hvdWxkIGJlIHJ1bm5pbmdcbiAgICogICAoY2YuIGBhdWRpb0NvbnRleHQuY3VycmVudFRpbWVgIHRoYXQgbmVlZHMgdXNlciBpbnRlcmFjdGlvbiB0byBzdGFydClcbiAgICoqL1xuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgU3luY0NsaWVudH5zZW5kRnVuY3Rpb25cbiAgICogQHNlZSB7QGxpbmtjb2RlIFN5bmNTZXJ2ZXJ+cmVjZWl2ZUZ1bmN0aW9ufVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGluZ0lkIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRQaW5nVGltZSB0aW1lLXN0YW1wIG9mIHBpbmcgZW1pc3Npb25cbiAgICoqL1xuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgU3luY0NsaWVudH5yZWNlaXZlRnVuY3Rpb25cbiAgICogQHNlZSB7QGxpbmtjb2RlIFN5bmNTZXJ2ZXJ+c2VuZEZ1bmN0aW9ufVxuICAgKiBAcGFyYW0ge1N5bmNDbGllbnR+cmVjZWl2ZUNhbGxiYWNrfSByZWNlaXZlQ2FsbGJhY2sgY2FsbGVkIG9uIGVhY2ggbWVzc2FnZVxuICAgKiAgIG1hdGNoaW5nIG1lc3NhZ2VUeXBlLlxuICAgKiovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fnJlY2VpdmVDYWxsYmFja1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGluZ0lkIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGllbnRQaW5nVGltZSB0aW1lLXN0YW1wIG9mIHBpbmcgZW1pc3Npb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlcnZlclBpbmdUaW1lIHRpbWUtc3RhbXAgb2YgcGluZyByZWNlcHRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlcnZlclBvbmdUaW1lIHRpbWUtc3RhbXAgb2YgcG9uZyBlbWlzc2lvblxuICAgKiovXG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBTeW5jQ2xpZW50fnJlcG9ydEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlcG9ydC5zdGF0dXMgYG5ld2AsIGBzdGFydHVwYCwgYHRyYWluaW5nYCAob2Zmc2V0XG4gICAqICAgYWRhcHRhdGlvbiksIG9yIGBzeW5jYCAob2Zmc2V0IGFuZCBzcGVlZCBhZGFwdGF0aW9uKS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcG9ydC5zdGF0dXNEdXJhdGlvbiBkdXJhdGlvbiBzaW5jZSBsYXN0IHN0YXR1c1xuICAgKiAgIGNoYW5nZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcG9ydC50aW1lT2Zmc2V0IHRpbWUgZGlmZmVyZW5jZSBiZXR3ZWVuIGxvY2FsIHRpbWUgYW5kXG4gICAqICAgc3luYyB0aW1lLCBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LmZyZXF1ZW5jeVJhdGlvIHRpbWUgcmF0aW8gYmV0d2VlbiBsb2NhbFxuICAgKiAgIHRpbWUgYW5kIHN5bmMgdGltZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlcG9ydC5jb25uZWN0aW9uIGBvZmZsaW5lYCBvciBgb25saW5lYFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LmNvbm5lY3Rpb25EdXJhdGlvbiBkdXJhdGlvbiBzaW5jZSBsYXN0IGNvbm5lY3Rpb25cbiAgICogICBjaGFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXBvcnQuY29ubmVjdGlvblRpbWVPdXQgZHVyYXRpb24sIGluIHNlY29uZHMsIGJlZm9yZVxuICAgKiAgIGEgdGltZS1vdXQgb2NjdXJzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LnRyYXZlbER1cmF0aW9uIGR1cmF0aW9uIG9mIGEgcGluZy1wb25nIHJvdW5kLXRyaXAsXG4gICAqICAgaW4gc2Vjb25kcywgbWVhbiBvdmVyIHRoZSB0aGUgbGFzdCBwaW5nLXBvbmcgc2VyaWVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LnRyYXZlbER1cmF0aW9uTWluIGR1cmF0aW9uIG9mIGEgcGluZy1wb25nXG4gICAqICAgcm91bmQtdHJpcCwgaW4gc2Vjb25kcywgbWluaW11bSBvdmVyIHRoZSB0aGUgbGFzdCBwaW5nLXBvbmcgc2VyaWVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwb3J0LnRyYXZlbER1cmF0aW9uTWF4IGR1cmF0aW9uIG9mIGEgcGluZy1wb25nXG4gICAqICAgcm91bmQtdHJpcCwgaW4gc2Vjb25kcywgbWF4aW11bSBvdmVyIHRoZSB0aGUgbGFzdCBwaW5nLXBvbmcgc2VyaWVzLlxuICAgKiovXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yLiBTZWUge0BsaW5rY29kZSBTeW5jQ2xpZW50fnN0YXJ0fSBtZXRob2QgdG9cbiAgICogYWN0dWFsbHkgc3RhcnQgYSBzeW5jaHJvbmlzYXRpb24gcHJvY2Vzcy5cbiAgICpcbiAgICogQGNvbnN0cnVjdHMgU3luY0NsaWVudFxuICAgKiBAcGFyYW0ge1N5bmNDbGllbnR+Z2V0VGltZUZ1bmN0aW9ufSBnZXRUaW1lRnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGluZ1RpbWVPdXREZWxheV0gcmFuZ2Ugb2YgZHVyYXRpb24gKGluIHNlY29uZHMpIHRvXG4gICAqIGNvbnNpZGVyIGEgcGluZyB3YXMgbm90IHBvbmdlZCBiYWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nVGltZU91dERlbGF5Lm1pbj0xXSBtaW4gYW5kIG1heCBtdXN0IGJlIHNldCB0b2dldGhlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGluZ1RpbWVPdXREZWxheS5tYXg9MzBdIG1pbiBhbmQgbWF4IG11c3QgYmUgc2V0IHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nU2VyaWVzSXRlcmF0aW9ucz0xMF0gbnVtYmVyIG9mIHBpbmctcG9uZ3MgaW4gYVxuICAgKiBzZXJpZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBpbmdTZXJpZXNQZXJpb2Q9MC4yNTBdIGludGVydmFsIChpbiBzZWNvbmRzKSBiZXR3ZWVuIHBpbmdzXG4gICAqIGluIGEgc2VyaWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nU2VyaWVzRGVsYXldIHJhbmdlIG9mIGludGVydmFsIChpblxuICAgKiBzZWNvbmRzKSBiZXR3ZWVuIHBpbmctcG9uZyBzZXJpZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBpbmdTZXJpZXNEZWxheS5taW49MTBdIG1pbiBhbmQgbWF4IG11c3QgYmUgc2V0IHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waW5nU2VyaWVzRGVsYXkubWF4PTIwXSBtaW4gYW5kIG1heCBtdXN0IGJlIHNldCB0b2dldGhlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9uZ1Rlcm1EYXRhVHJhaW5pbmdEdXJhdGlvbj0xMjBdIGR1cmF0aW9uIG9mXG4gICAqIHRyYWluaW5nLCBpbiBzZWNvbmRzLCBhcHByb3hpbWF0ZWx5LCBiZWZvcmUgdXNpbmcgdGhlIGVzdGltYXRlIG9mXG4gICAqIGNsb2NrIGZyZXF1ZW5jeVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9uZ1Rlcm1EYXRhRHVyYXRpb249OTAwXSBlc3RpbWF0ZSBzeW5jaHJvbmlzYXRpb24gb3ZlclxuICAgKiAgdGhpcyBkdXJhdGlvbiwgaW4gc2Vjb25kcywgYXBwcm94aW1hdGVseVxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2V0VGltZUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnBpbmdUaW1lb3V0RGVsYXkgPSBvcHRpb25zLnBpbmdUaW1lb3V0RGVsYXlcbiAgICAgIHx8IHsgbWluOiAxLCBtYXg6IDMwIH07XG4gICAgb3JkZXJNaW5NYXgodGhpcy5waW5nVGltZW91dERlbGF5KTtcblxuICAgIHRoaXMucGluZ1Nlcmllc0l0ZXJhdGlvbnMgPSBvcHRpb25zLnBpbmdTZXJpZXNJdGVyYXRpb25zIHx8IDEwO1xuICAgIHRoaXMucGluZ1Nlcmllc1BlcmlvZCA9ICh0eXBlb2Ygb3B0aW9ucy5waW5nU2VyaWVzUGVyaW9kICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMucGluZ1Nlcmllc1BlcmlvZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAuMjUwKTtcbiAgICB0aGlzLnBpbmdTZXJpZXNEZWxheSA9IG9wdGlvbnMucGluZ1Nlcmllc0RlbGF5XG4gICAgICB8fCB7IG1pbjogMTAsIG1heDogMjAgfTtcbiAgICBvcmRlck1pbk1heCh0aGlzLnBpbmdTZXJpZXNEZWxheSk7XG5cbiAgICB0aGlzLnBpbmdEZWxheSA9IDA7IC8vIGN1cnJlbnQgZGVsYXkgYmVmb3JlIG5leHQgcGluZ1xuICAgIHRoaXMudGltZW91dElkID0gMDsgLy8gdG8gY2FuY2VsIHRpbWVvdXQgb24gcG9uZ1xuICAgIHRoaXMucGluZ0lkID0gMDsgLy8gYWJzb2x1dGUgSUQgdG8gbWFjaCBwb25nIGFnYWluc3RcblxuICAgIHRoaXMucGluZ1Nlcmllc0NvdW50ID0gMDsgLy8gZWxhcHNlZCBwaW5ncyBpbiBhIHNlcmllc1xuICAgIHRoaXMuc2VyaWVzRGF0YSA9IFtdOyAvLyBjaXJjdWxhciBidWZmZXJcbiAgICB0aGlzLnNlcmllc0RhdGFOZXh0SW5kZXggPSAwOyAvLyBuZXh0IGluZGV4IHRvIHdyaXRlIGluIGNpcmN1bGFyIGJ1ZmZlclxuICAgIHRoaXMuc2VyaWVzRGF0YUxlbmd0aCA9IHRoaXMucGluZ1Nlcmllc0l0ZXJhdGlvbnM7IC8vIHNpemUgb2YgY2lyY3VsYXIgYnVmZmVyXG5cbiAgICB0aGlzLmxvbmdUZXJtRGF0YVRyYWluaW5nRHVyYXRpb25cbiAgICAgID0gb3B0aW9ucy5sb25nVGVybURhdGFUcmFpbmluZ0R1cmF0aW9uIHx8IDEyMDtcblxuICAgIC8vIHVzZSBhIGZpeGVkLXNpemUgY2lyY3VsYXIgYnVmZmVyLCBldmVuIGlmIGl0IGRvZXMgbm90IG1hdGNoXG4gICAgLy8gZXhhY3RseSB0aGUgcmVxdWlyZWQgZHVyYXRpb25cbiAgICB0aGlzLmxvbmdUZXJtRGF0YUR1cmF0aW9uID0gb3B0aW9ucy5sb25nVGVybURhdGFEdXJhdGlvbiB8fCA5MDA7XG4gICAgdGhpcy5sb25nVGVybURhdGFMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIDIsXG4gICAgICB0aGlzLmxvbmdUZXJtRGF0YUR1cmF0aW9uIC9cbiAgICAgICAgKDAuNSAqICh0aGlzLnBpbmdTZXJpZXNEZWxheS5taW4gKyB0aGlzLnBpbmdTZXJpZXNEZWxheS5tYXgpICkgKTtcblxuICAgIHRoaXMubG9uZ1Rlcm1EYXRhID0gW107IC8vIGNpcmN1bGFyIGJ1ZmZlclxuICAgIHRoaXMubG9uZ1Rlcm1EYXRhTmV4dEluZGV4ID0gMDsgLy8gbmV4dCBpbmRleCB0byB3cml0ZSBpbiBjaXJjdWxhciBidWZmZXJcblxuICAgIHRoaXMudGltZU9mZnNldCA9IDA7IC8vIG1lYW4gb2YgKHNlcnZlclRpbWUgLSBjbGllbnRUaW1lKSBpbiB0aGUgbGFzdCBzZXJpZXNcbiAgICB0aGlzLnRyYXZlbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyYXZlbER1cmF0aW9uTWluID0gMDtcbiAgICB0aGlzLnRyYXZlbER1cmF0aW9uTWF4ID0gMDtcblxuICAgIC8vIFQodCkgPSBUMCArIFIgKiAodCAtIHQwKVxuICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSA9IDA7IC8vIFQwXG4gICAgdGhpcy5jbGllbnRUaW1lUmVmZXJlbmNlID0gMDsgLy8gdDBcbiAgICB0aGlzLmZyZXF1ZW5jeVJhdGlvID0gMTsgLy8gUlxuXG4gICAgdGhpcy5waW5nVGltZW91dERlbGF5LmN1cnJlbnQgPSB0aGlzLnBpbmdUaW1lb3V0RGVsYXkubWluO1xuXG4gICAgdGhpcy5nZXRUaW1lRnVuY3Rpb24gPSBnZXRUaW1lRnVuY3Rpb247XG5cbiAgICB0aGlzLnN0YXR1cyA9ICduZXcnO1xuICAgIHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUgPSAwO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzID0gJ29mZmxpbmUnO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1c0NoYW5nZWRUaW1lID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc3RhdHVzLCBhbmQgc2V0IHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUsIHRvIGxhdGVyXG4gICAqIHVzZSBzZWUge0BsaW5rY29kZSBTeW5jQ2xpZW50fmdldFN0YXR1c0R1cmF0aW9ufVxuICAgKiBhbmQge0BsaW5rY29kZSBTeW5jQ2xpZW50fnJlcG9ydFN0YXR1c30uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBTeW5jQ2xpZW50fnNldFN0YXR1c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoaXNcbiAgICovXG4gIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICBpZihzdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUgPSB0aGlzLmdldExvY2FsVGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGltZSBzaW5jZSBsYXN0IHN0YXR1cyBjaGFuZ2UuIFNlZSB7QGxpbmtjb2RlIFN5bmNDbGllbnR+c2V0U3RhdHVzfVxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5nZXRTdGF0dXNEdXJhdGlvblxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aW1lLCBpbiBzZWNvbmRzLCBzaW5jZSBsYXN0IHN0YXR1cyBjaGFuZ2UuXG4gICAqL1xuICBnZXRTdGF0dXNEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5nZXRMb2NhbFRpbWUoKSAtIHRoaXMuc3RhdHVzQ2hhbmdlZFRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb25uZWN0aW9uU3RhdHVzLCBhbmQgc2V0IHRoaXMuY29ubmVjdGlvblN0YXR1c0NoYW5nZWRUaW1lLFxuICAgKiB0byBsYXRlciB1c2Ugc2VlIHtAbGlua2NvZGUgU3luY0NsaWVudH5nZXRDb25uZWN0aW9uU3RhdHVzRHVyYXRpb259XG4gICAqIGFuZCB7QGxpbmtjb2RlIFN5bmNDbGllbnR+cmVwb3J0U3RhdHVzfS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIFN5bmNDbGllbnR+c2V0Q29ubmVjdGlvblN0YXR1c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ubmVjdGlvblN0YXR1c1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGlzXG4gICAqL1xuICBzZXRDb25uZWN0aW9uU3RhdHVzKGNvbm5lY3Rpb25TdGF0dXMpIHtcbiAgICBpZihjb25uZWN0aW9uU3RhdHVzICE9PSB0aGlzLmNvbm5lY3Rpb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1cyA9IGNvbm5lY3Rpb25TdGF0dXM7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkVGltZSA9IHRoaXMuZ2V0TG9jYWxUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aW1lIHNpbmNlIGxhc3QgY29ubmVjdGlvblN0YXR1cyBjaGFuZ2UuXG4gICAqIFNlZSB7QGxpbmtjb2RlIFN5bmNDbGllbnR+c2V0Q29ubmVjdGlvblN0YXR1c31cbiAgICpcbiAgICogQGZ1bmN0aW9uIFN5bmNDbGllbnR+Z2V0Q29ubmVjdGlvblN0YXR1c0R1cmF0aW9uXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRpbWUsIGluIHNlY29uZHMsIHNpbmNlIGxhc3QgY29ubmVjdGlvblN0YXR1cyBjaGFuZ2UuXG4gICAqL1xuICBnZXRDb25uZWN0aW9uU3RhdHVzRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuZ2V0TG9jYWxUaW1lKCkgLSB0aGlzLmNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3J0IHRoZSBzdGF0dXMgb2YgdGhlIHN5bmNocm9uaXNhdGlvbiBwcm9jZXNzLCBpZlxuICAgKiByZXBvcnRGdW5jdGlvbiBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5yZXBvcnRTdGF0dXNcbiAgICogQHBhcmFtIHtTeW5jQ2xpZW50fnJlcG9ydEZ1bmN0aW9ufSByZXBvcnRGdW5jdGlvblxuICAgKi9cbiAgcmVwb3J0U3RhdHVzKHJlcG9ydEZ1bmN0aW9uKSB7XG4gICAgaWYodHlwZW9mIHJlcG9ydEZ1bmN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVwb3J0RnVuY3Rpb24oe1xuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICBzdGF0dXNEdXJhdGlvbjogdGhpcy5nZXRTdGF0dXNEdXJhdGlvbigpLFxuICAgICAgICB0aW1lT2Zmc2V0OiB0aGlzLnRpbWVPZmZzZXQsXG4gICAgICAgIGZyZXF1ZW5jeVJhdGlvOiB0aGlzLmZyZXF1ZW5jeVJhdGlvLFxuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLmNvbm5lY3Rpb25TdGF0dXMsXG4gICAgICAgIGNvbm5lY3Rpb25EdXJhdGlvbjogdGhpcy5nZXRDb25uZWN0aW9uU3RhdHVzRHVyYXRpb24oKSxcbiAgICAgICAgY29ubmVjdGlvblRpbWVPdXQ6IHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50LFxuICAgICAgICB0cmF2ZWxEdXJhdGlvbjogdGhpcy50cmF2ZWxEdXJhdGlvbixcbiAgICAgICAgdHJhdmVsRHVyYXRpb25NaW46IHRoaXMudHJhdmVsRHVyYXRpb25NaW4sXG4gICAgICAgIHRyYXZlbER1cmF0aW9uTWF4OiB0aGlzLnRyYXZlbER1cmF0aW9uTWF4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0byBzZW5kIHBpbmcgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBTeW5jQ2xpZW50fl9fc3luY0xvb3BcbiAgICogQHBhcmFtIHtTeW5jQ2xpZW50fnNlbmRGdW5jdGlvbn0gc2VuZEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3luY0NsaWVudH5yZXBvcnRGdW5jdGlvbn0gcmVwb3J0RnVuY3Rpb25cbiAgICovXG4gIF9fc3luY0xvb3Aoc2VuZEZ1bmN0aW9uLCByZXBvcnRGdW5jdGlvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgKyt0aGlzLnBpbmdJZDtcbiAgICBzZW5kRnVuY3Rpb24odGhpcy5waW5nSWQsIHRoaXMuZ2V0TG9jYWxUaW1lKCkpO1xuXG4gICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGluY3JlYXNlIHRpbWVvdXQgZHVyYXRpb24gb24gdGltZW91dCwgdG8gYXZvaWQgb3ZlcmZsb3dcbiAgICAgIHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50ID0gTWF0aC5taW4odGhpcy5waW5nVGltZW91dERlbGF5LmN1cnJlbnQgKiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RGVsYXkubWF4KTtcbiAgICAgIGxvZygnc3luYzpwaW5nIHRpbWVvdXQgPiAlcycsIHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50KTtcbiAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnb2ZmbGluZScpO1xuICAgICAgdGhpcy5yZXBvcnRTdGF0dXMocmVwb3J0RnVuY3Rpb24pO1xuICAgICAgLy8gcmV0cnkgKHllcywgYWx3YXlzIGluY3JlbWVudCBwaW5nSWQpXG4gICAgICB0aGlzLl9fc3luY0xvb3Aoc2VuZEZ1bmN0aW9uLCByZXBvcnRGdW5jdGlvbik7XG4gICAgfSwgTWF0aC5jZWlsKDEwMDAgKiB0aGlzLnBpbmdUaW1lb3V0RGVsYXkuY3VycmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgc3luY2hyb25pc2F0aW9uIHByb2Nlc3MgYnkgcmVnaXN0ZXJpbmcgdGhlIHJlY2VpdmVcbiAgICogZnVuY3Rpb24gcGFzc2VkIGFzIHNlY29uZCBwYXJhbWV0ZXIuIFRoZW4sIHNlbmQgcmVndWxhciBtZXNzYWdlc1xuICAgKiB0byB0aGUgc2VydmVyLCB1c2luZyB0aGUgc2VuZCBmdW5jdGlvbiBwYXNzZWQgYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5zdGFydFxuICAgKiBAcGFyYW0ge1N5bmNDbGllbnR+c2VuZEZ1bmN0aW9ufSBzZW5kRnVuY3Rpb25cbiAgICogQHBhcmFtIHtTeW5jQ2xpZW50fnJlY2VpdmVGdW5jdGlvbn0gcmVjZWl2ZUZ1bmN0aW9uIHRvIHJlZ2lzdGVyXG4gICAqIEBwYXJhbSB7U3luY0NsaWVudH5yZXBvcnRGdW5jdGlvbn0gcmVwb3J0RnVuY3Rpb24gaWYgZGVmaW5lZCwgaXMgY2FsbGVkIHRvXG4gICAqICAgcmVwb3J0IHRoZSBzdGF0dXMsIG9uIGVhY2ggc3RhdHVzIGNoYW5nZVxuICAgKi9cbiAgc3RhcnQoc2VuZEZ1bmN0aW9uLCByZWNlaXZlRnVuY3Rpb24sIHJlcG9ydEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5zZXRTdGF0dXMoJ3N0YXJ0dXAnKTtcbiAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0dXMoJ29mZmxpbmUnKTtcblxuICAgIHRoaXMuc2VyaWVzRGF0YSA9IFtdO1xuICAgIHRoaXMuc2VyaWVzRGF0YU5leHRJbmRleCA9IDA7XG5cbiAgICB0aGlzLmxvbmdUZXJtRGF0YSA9IFtdO1xuICAgIHRoaXMubG9uZ1Rlcm1EYXRhTmV4dEluZGV4ID0gMDtcblxuICAgIHJlY2VpdmVGdW5jdGlvbigocGluZ0lkLCBjbGllbnRQaW5nVGltZSwgc2VydmVyUGluZ1RpbWUsIHNlcnZlclBvbmdUaW1lKSA9PiB7XG4gICAgICAvLyBhY2NlcHQgb25seSB0aGUgcG9uZyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBsYXN0IHBpbmdcbiAgICAgIGlmIChwaW5nSWQgPT09IHRoaXMucGluZ0lkKSB7XG4gICAgICAgICsrdGhpcy5waW5nU2VyaWVzQ291bnQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnb25saW5lJyk7XG4gICAgICAgIC8vIHJlZHVjZSB0aW1lb3V0IGR1cmF0aW9uIG9uIHBvbmcsIGZvciBiZXR0ZXIgcmVhY3Rpdml0eVxuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RGVsYXkuY3VycmVudCA9IE1hdGgubWF4KHRoaXMucGluZ1RpbWVvdXREZWxheS5jdXJyZW50ICogMC43NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RGVsYXkubWluKTtcblxuICAgICAgICAvLyB0aW1lLWRpZmZlcmVuY2VzIGFyZSB2YWxpZCBvbiBhIHNpbmdsZS1zaWRlIG9ubHkgKGNsaWVudCBvciBzZXJ2ZXIpXG4gICAgICAgIGNvbnN0IGNsaWVudFBvbmdUaW1lID0gdGhpcy5nZXRMb2NhbFRpbWUoKTtcbiAgICAgICAgY29uc3QgY2xpZW50VGltZSA9IDAuNSAqIChjbGllbnRQb25nVGltZSArIGNsaWVudFBpbmdUaW1lKTtcbiAgICAgICAgY29uc3Qgc2VydmVyVGltZSA9IDAuNSAqIChzZXJ2ZXJQb25nVGltZSArIHNlcnZlclBpbmdUaW1lKTtcbiAgICAgICAgY29uc3QgdHJhdmVsRHVyYXRpb24gPSBNYXRoLm1heCgwLCAoY2xpZW50UG9uZ1RpbWUgLSBjbGllbnRQaW5nVGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIChzZXJ2ZXJQb25nVGltZSAtIHNlcnZlclBpbmdUaW1lKSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFRpbWUgPSBzZXJ2ZXJUaW1lIC0gY2xpZW50VGltZTtcblxuICAgICAgICAvLyBvcmRlciBpcyBpbXBvcnRhbnQgZm9yIHNvcnRpbmcsIGxhdGVyLlxuICAgICAgICB0aGlzLnNlcmllc0RhdGFbdGhpcy5zZXJpZXNEYXRhTmV4dEluZGV4XVxuICAgICAgICAgID0gW3RyYXZlbER1cmF0aW9uLCBvZmZzZXRUaW1lLCBjbGllbnRUaW1lLCBzZXJ2ZXJUaW1lXTtcbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhTmV4dEluZGV4ID0gKCsrdGhpcy5zZXJpZXNEYXRhTmV4dEluZGV4KSAlIHRoaXMuc2VyaWVzRGF0YUxlbmd0aDtcblxuICAgICAgICAvLyBsb2coJ3BpbmcgJXMsIHRyYXZlbCA9ICVzLCBvZmZzZXQgPSAlcywgY2xpZW50ID0gJXMsIHNlcnZlciA9ICVzJyxcbiAgICAgICAgLy8gICAgICAgcGluZ0lkLCB0cmF2ZWxEdXJhdGlvbiwgb2Zmc2V0VGltZSwgY2xpZW50VGltZSwgc2VydmVyVGltZSk7XG5cbiAgICAgICAgLy8gZW5kIG9mIGEgc2VyaWVzXG4gICAgICAgIGlmICh0aGlzLnBpbmdTZXJpZXNDb3VudCA+PSB0aGlzLnBpbmdTZXJpZXNJdGVyYXRpb25zXG4gICAgICAgICAgICAmJiB0aGlzLnNlcmllc0RhdGEubGVuZ3RoID49IHRoaXMuc2VyaWVzRGF0YUxlbmd0aCkge1xuICAgICAgICAgIC8vIHBsYW4gdGhlIGJlZ2luaW5nIG9mIHRoZSBuZXh0IHNlcmllc1xuICAgICAgICAgIHRoaXMucGluZ0RlbGF5ID0gdGhpcy5waW5nU2VyaWVzRGVsYXkubWluXG4gICAgICAgICAgICArIE1hdGgucmFuZG9tKCkgKiAodGhpcy5waW5nU2VyaWVzRGVsYXkubWF4IC0gdGhpcy5waW5nU2VyaWVzRGVsYXkubWluKTtcbiAgICAgICAgICB0aGlzLnBpbmdTZXJpZXNDb3VudCA9IDA7XG5cbiAgICAgICAgICAvLyBzb3J0IGJ5IHRyYXZlbCB0aW1lIGZpcnN0LCB0aGVuIG9mZnNldCB0aW1lLlxuICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IHRoaXMuc2VyaWVzRGF0YS5zbGljZSgwKS5zb3J0KGRhdGFDb21wYXJlKTtcblxuICAgICAgICAgIGNvbnN0IHNlcmllc1RyYXZlbER1cmF0aW9uID0gc29ydGVkWzBdWzBdO1xuXG4gICAgICAgICAgLy8gV2hlbiB0aGUgY2xvY2sgdGljayBpcyBsb25nIGVub3VnaCxcbiAgICAgICAgICAvLyBzb21lIHRyYXZlbCB0aW1lcyAoZGltZW5zaW9uIDApIG1pZ2h0IGJlIGlkZW50aWNhbC5cbiAgICAgICAgICAvLyBUaGVuLCB1c2UgdGhlIG9mZnNldCBtZWRpYW4gKGRpbWVuc2lvbiAxIGlzIHRoZSBzZWNvbmQgc29ydCBrZXkpXG4gICAgICAgICAgLy8gb2Ygc2hvcnRlc3QgdHJhdmVsIGR1cmF0aW9uXG4gICAgICAgICAgbGV0IHF1aWNrID0gMDtcbiAgICAgICAgICB3aGlsZShxdWljayA8IHNvcnRlZC5sZW5ndGggJiYgc29ydGVkW3F1aWNrXVswXSA8PSBzZXJpZXNUcmF2ZWxEdXJhdGlvbiAqIDEuMDEpIHtcbiAgICAgICAgICAgICsrcXVpY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1aWNrID0gTWF0aC5tYXgoMCwgcXVpY2sgLSAxKTtcbiAgICAgICAgICBjb25zdCBtZWRpYW4gPSBNYXRoLmZsb29yKHF1aWNrIC8gMik7XG5cbiAgICAgICAgICBjb25zdCBzZXJpZXNDbGllbnRUaW1lID0gc29ydGVkW21lZGlhbl1bMl07XG4gICAgICAgICAgY29uc3Qgc2VyaWVzU2VydmVyVGltZSA9IHNvcnRlZFttZWRpYW5dWzNdO1xuICAgICAgICAgIGNvbnN0IHNlcmllc0NsaWVudFNxdWFyZWRUaW1lID0gc2VyaWVzQ2xpZW50VGltZSAqIHNlcmllc0NsaWVudFRpbWU7XG4gICAgICAgICAgY29uc3Qgc2VyaWVzQ2xpZW50U2VydmVyVGltZSA9IHNlcmllc0NsaWVudFRpbWUgKiBzZXJpZXNTZXJ2ZXJUaW1lO1xuXG4gICAgICAgICAgdGhpcy5sb25nVGVybURhdGFbdGhpcy5sb25nVGVybURhdGFOZXh0SW5kZXhdXG4gICAgICAgICAgICA9IFtzZXJpZXNUcmF2ZWxEdXJhdGlvbiwgc2VyaWVzQ2xpZW50VGltZSwgc2VyaWVzU2VydmVyVGltZSxcbiAgICAgICAgICAgICAgIHNlcmllc0NsaWVudFNxdWFyZWRUaW1lLCBzZXJpZXNDbGllbnRTZXJ2ZXJUaW1lXTtcbiAgICAgICAgICB0aGlzLmxvbmdUZXJtRGF0YU5leHRJbmRleCA9ICgrK3RoaXMubG9uZ1Rlcm1EYXRhTmV4dEluZGV4KSAlIHRoaXMubG9uZ1Rlcm1EYXRhTGVuZ3RoO1xuXG4gICAgICAgICAgLy8gbWVhbiBvZiB0aGUgdGltZSBvZmZzZXQgb3ZlciAzIHNhbXBsZXMgYXJvdW5kIG1lZGlhblxuICAgICAgICAgIC8vIChsaW1pdGVkIHRvIHNob3J0ZXN0IHRyYXZlbCBkdXJhdGlvbilcbiAgICAgICAgICBjb25zdCBhcm91bmRNZWRpYW4gPSBzb3J0ZWQuc2xpY2UoTWF0aC5tYXgoMCwgbWVkaWFuIC0gMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHF1aWNrLCBtZWRpYW4gKyAxKSArIDEpO1xuICAgICAgICAgIHRoaXMudGltZU9mZnNldCA9IG1lYW4oYXJvdW5kTWVkaWFuLCAxKTtcblxuICAgICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSAnc3RhcnR1cCdcbiAgICAgICAgICAgICB8fCAodGhpcy5zdGF0dXMgPT09ICd0cmFpbmluZydcbiAgICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRTdGF0dXNEdXJhdGlvbigpIDwgdGhpcy5sb25nVGVybURhdGFUcmFpbmluZ0R1cmF0aW9uKSApIHtcbiAgICAgICAgICAgIC8vIHNldCBvbmx5IHRoZSBwaGFzZSBvZmZzZXQsIG5vdCB0aGUgZnJlcXVlbmN5XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRpbWVSZWZlcmVuY2UgPSB0aGlzLnRpbWVPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFRpbWVSZWZlcmVuY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3lSYXRpbyA9IDE7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cygndHJhaW5pbmcnKTtcbiAgICAgICAgICAgIGxvZygnVCA9ICVzICsgJXMgKiAoJXMgLSAlcykgPSAlcycsXG4gICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRpbWVSZWZlcmVuY2UsIHRoaXMuZnJlcXVlbmN5UmF0aW8sXG4gICAgICAgICAgICAgICAgICBzZXJpZXNDbGllbnRUaW1lLCB0aGlzLmNsaWVudFRpbWVSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICB0aGlzLmdldFN5bmNUaW1lKHNlcmllc0NsaWVudFRpbWUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZigodGhpcy5zdGF0dXMgPT09ICd0cmFpbmluZydcbiAgICAgICAgICAgICAgJiYgdGhpcy5nZXRTdGF0dXNEdXJhdGlvbigpID49IHRoaXMubG9uZ1Rlcm1EYXRhVHJhaW5pbmdEdXJhdGlvbilcbiAgICAgICAgICAgICB8fCB0aGlzLnN0YXR1cyA9PT0gJ3N5bmMnKSB7XG4gICAgICAgICAgICAvLyBsaW5lYXIgcmVncmVzc2lvbiwgUiA9IGNvdmFyaWFuY2UodCxUKSAvIHZhcmlhbmNlKHQpXG4gICAgICAgICAgICBjb25zdCByZWdDbGllbnRUaW1lID0gbWVhbih0aGlzLmxvbmdUZXJtRGF0YSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZWdTZXJ2ZXJUaW1lID0gbWVhbih0aGlzLmxvbmdUZXJtRGF0YSwgMik7XG4gICAgICAgICAgICBjb25zdCByZWdDbGllbnRTcXVhcmVkVGltZSA9IG1lYW4odGhpcy5sb25nVGVybURhdGEsIDMpO1xuICAgICAgICAgICAgY29uc3QgcmVnQ2xpZW50U2VydmVyVGltZSA9IG1lYW4odGhpcy5sb25nVGVybURhdGEsIDQpO1xuXG4gICAgICAgICAgICBjb25zdCBjb3ZhcmlhbmNlID0gcmVnQ2xpZW50U2VydmVyVGltZSAtIHJlZ0NsaWVudFRpbWUgKiByZWdTZXJ2ZXJUaW1lO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSByZWdDbGllbnRTcXVhcmVkVGltZSAtIHJlZ0NsaWVudFRpbWUgKiByZWdDbGllbnRUaW1lO1xuICAgICAgICAgICAgaWYodmFyaWFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSBmcmVxIGFuZCBzaGlmdFxuICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeVJhdGlvID0gY292YXJpYW5jZSAvIHZhcmlhbmNlO1xuICAgICAgICAgICAgICB0aGlzLmNsaWVudFRpbWVSZWZlcmVuY2UgPSByZWdDbGllbnRUaW1lO1xuICAgICAgICAgICAgICB0aGlzLnNlcnZlclRpbWVSZWZlcmVuY2UgPSByZWdTZXJ2ZXJUaW1lO1xuXG4gICAgICAgICAgICAgIC8vIDAuMDUlIGlzIGEgbG90ICg1MDAgUFBNLCBsaWtlIGFuIG9sZCBtZWNoYW5pY2FsIGNsb2NrKVxuICAgICAgICAgICAgICBpZih0aGlzLmZyZXF1ZW5jeVJhdGlvID4gMC45OTk1ICYmIHRoaXMuZnJlcXVlbmN5UmF0aW8gPCAxLjAwMDUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cygnc3luYycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZygnY2xvY2sgZnJlcXVlbmN5IHJhdGlvIG91dCBvZiBzeW5jOiAlcywgdHJhaW5pbmcgYWdhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5UmF0aW8pO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSB0cmFpbmluZyBhZ2FpbiBmcm9tIHRoZSBsYXN0IHNlcmllc1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSA9IHRoaXMudGltZU9mZnNldDsgLy8gb2Zmc2V0IG9ubHlcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudFRpbWVSZWZlcmVuY2UgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5UmF0aW8gPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKCd0cmFpbmluZycpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sb25nVGVybURhdGFbMF1cbiAgICAgICAgICAgICAgICAgID0gW3Nlcmllc1RyYXZlbER1cmF0aW9uLCBzZXJpZXNDbGllbnRUaW1lLCBzZXJpZXNTZXJ2ZXJUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2xpZW50U3F1YXJlZFRpbWUsIHNlcmllc0NsaWVudFNlcnZlclRpbWVdO1xuICAgICAgICAgICAgICAgIHRoaXMubG9uZ1Rlcm1EYXRhLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5sb25nVGVybURhdGFOZXh0SW5kZXggPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZygnVCA9ICVzICsgJXMgKiAoJXMgLSAlcykgPSAlcycsXG4gICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclRpbWVSZWZlcmVuY2UsIHRoaXMuZnJlcXVlbmN5UmF0aW8sXG4gICAgICAgICAgICAgICAgICBzZXJpZXNDbGllbnRUaW1lLCB0aGlzLmNsaWVudFRpbWVSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICB0aGlzLmdldFN5bmNUaW1lKHNlcmllc0NsaWVudFRpbWUpICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50cmF2ZWxEdXJhdGlvbiA9IG1lYW4oc29ydGVkLCAwKTtcbiAgICAgICAgICB0aGlzLnRyYXZlbER1cmF0aW9uTWluID0gc29ydGVkWzBdWzBdO1xuICAgICAgICAgIHRoaXMudHJhdmVsRHVyYXRpb25NYXggPSBzb3J0ZWRbc29ydGVkLmxlbmd0aCAtIDFdWzBdO1xuXG4gICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMocmVwb3J0RnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIGFyZSBpbiBhIHNlcmllcywgdXNlIHRoZSBwaW5nSW50ZXJ2YWwgdmFsdWVcbiAgICAgICAgICB0aGlzLnBpbmdEZWxheSA9IHRoaXMucGluZ1Nlcmllc1BlcmlvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fX3N5bmNMb29wKHNlbmRGdW5jdGlvbiwgcmVwb3J0RnVuY3Rpb24pO1xuICAgICAgICB9LCBNYXRoLmNlaWwoMTAwMCAqIHRoaXMucGluZ0RlbGF5KSk7XG4gICAgICB9ICAvLyBwaW5nIGFuZCBwb25nIElEIG1hdGNoXG4gICAgfSk7IC8vIHJlY2VpdmUgZnVuY3Rpb25cblxuICAgIHRoaXMuX19zeW5jTG9vcChzZW5kRnVuY3Rpb24sIHJlcG9ydEZ1bmN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbG9jYWwgdGltZSwgb3IgY29udmVydCBhIHN5bmNocm9uaXNlZCB0aW1lIHRvIGEgbG9jYWwgdGltZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIFN5bmNDbGllbnR+Z2V0TG9jYWxUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzeW5jVGltZSB1bmRlZmluZWQgdG8gZ2V0IGxvY2FsIHRpbWVcbiAgICogQHJldHVybnMge051bWJlcn0gbG9jYWwgdGltZSwgaW4gc2Vjb25kc1xuICAgKi9cbiAgZ2V0TG9jYWxUaW1lKHN5bmNUaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBzeW5jVGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGNvbnZlcnNpb246IHQoVCkgPSB0MCArIChUIC0gVDApIC8gUlxuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50VGltZVJlZmVyZW5jZVxuICAgICAgICArIChzeW5jVGltZSAtIHRoaXMuc2VydmVyVGltZVJlZmVyZW5jZSkgLyB0aGlzLmZyZXF1ZW5jeVJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFkIGxvY2FsIGNsb2NrXG4gICAgICByZXR1cm4gdGhpcy5nZXRUaW1lRnVuY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN5bmNocm9uaXNlZCB0aW1lLCBvciBjb252ZXJ0IGEgbG9jYWwgdGltZSB0byBhIHN5bmNocm9uaXNlZCB0aW1lLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gU3luY0NsaWVudH5nZXRTeW5jVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYWxUaW1lIHVuZGVmaW5lZCB0byBnZXQgc3luY2hyb25pc2VkIHRpbWVcbiAgICogQHJldHVybnMge051bWJlcn0gc3luY2hyb25pc2VkIHRpbWUsIGluIHNlY29uZHMuXG4gICAqL1xuICBnZXRTeW5jVGltZShsb2NhbFRpbWUgPSB0aGlzLmdldExvY2FsVGltZSgpKSB7XG4gICAgLy8gYWx3YXlzIGNvbnZlcnQ6IFQodCkgPSBUMCArIFIgKiAodCAtIHQwKVxuICAgIHJldHVybiB0aGlzLnNlcnZlclRpbWVSZWZlcmVuY2VcbiAgICAgICsgdGhpcy5mcmVxdWVuY3lSYXRpbyAqIChsb2NhbFRpbWUgLSB0aGlzLmNsaWVudFRpbWVSZWZlcmVuY2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN5bmNDbGllbnQ7XG4iXX0=